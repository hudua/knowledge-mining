@page "/search"
@using KnowledgeMining.UI.Models
@using KnowledgeMining.UI.Services.Search.Models

@implements IAsyncDisposable
@inject ISearchService _searchService
@inject IJSRuntime JS

<PageTitle>Search</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    <MudGrid>
        <MudItem xs="0" md="1">

        </MudItem>
        <MudItem xs="12" md="2">
            <MudAutocomplete T="string" @bind-Value="SearchText"
                             SearchFunc="@AutoComplete"
                             ResetValueOnEmptyText="true"
                             CoerceText="true"
                             CoerceValue="true"
                             OnKeyPress="@SearchIfEnterPressed"
                             Immediate="true"
                             AdornmentIcon="@Icons.Material.Filled.Search"
                             AdornmentColor="Color.Primary"
                             OnAdornmentClick="@(() => SearchDocuments(new SearchRequest(SearchText, _selectedPage, poligonString, _selectedFacets)))"
                             Variant="Variant.Outlined"
                             Margin="Margin.None" />
            <FacetsFilterComponent Facets="@_searchState.Facets" OnFacetSelectedChanged="UpdateSearchFacetsAndSearch"></FacetsFilterComponent>
        </MudItem>
        <MudItem xs="12" md="9">
            <MudTabs Elevation="0" Outlined="true" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-6" Class="mt-1">
                <div class="d-flex flex-column">
                    <MudTabPanel Text="Search Results">
                        <SearchResultsComponent Documents="@_searchState.Documents" TotalCount="@_searchState.TotalCount" TotalPages="@_searchState.TotalPages" OnDocumentClicked="@GetDocumentDetails" OnPageClicked="@SearchPageSelected"></SearchResultsComponent>
                    </MudTabPanel>
                    <MudTabPanel Text="Entity Map" OnClick="@(() => GenerateEntityMap())">
                        <div class="d-flex flex-row">
                            <div class="flex-grow-1">
                                <svg id="@_entityMapContainerId"></svg>
                            </div>
                            <div class="d-flex flex-column">
                                <MudSlider Min="1" Max="3" Step="1" Value="_maxLevels" T="int" ValueChanged="UpdateEntityMapLevel" ValueLabel="true">Max Levels: @_maxLevels</MudSlider>
                                <MudSlider Min="3" Max="30" Step="1" Value="_maxNodes" T="int" ValueChanged="UpdateEntityMapNodes" ValueLabel="true">Max Nodes: @_maxNodes</MudSlider>
                                <MudExpansionPanels Class="mt-6">
                                    <MudExpansionPanel Text="Facets">
                                        <MudSelect T="string" Placeholder="Select facets" MultiSelection="true" SelectedValuesChanged="UpdateEntityMapFacets">
                                            @foreach (var facet in _searchState.FacetableFields)
                                            {
                                                <MudSelectItem T="string" Value="@facet">@facet</MudSelectItem>
                                            }
                                        </MudSelect>
                                    </MudExpansionPanel>
                                </MudExpansionPanels>
                            </div>
                        </div>
                    </MudTabPanel>
                </div>
            </MudTabs>
        </MudItem>
    </MudGrid>
    <DocumentDetailsComponent @bind-IsVisible="_showDocumentDetails" Document="documentDetails"></DocumentDetailsComponent>
</MudContainer>

@code {
    [Parameter, SupplyParameterFromQuery(Name = "q")] public string? SearchText { get; set; }

    private SearchState _searchState = new();

    private int _selectedPage;
    private List<SearchFacet> _selectedFacets = new();
    private string poligonString = string.Empty;

    private bool _showDocumentDetails = false;
    private DocumentFullMetadata documentDetails;

    private string _entityMapContainerId = "entity-map";
    private int _maxLevels = 10;
    private int _maxNodes = 10;
    private IEnumerable<string> _selectedEntityMapFacets = new HashSet<string>();
    private IJSObjectReference? module;

    protected override async Task OnInitializedAsync()
    {
        var request = new SearchRequest(SearchText, _selectedPage, poligonString, _selectedFacets);
        await SearchDocuments(request);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/entityMapV2.js");
        }
    }

    private async Task<IEnumerable<string>> AutoComplete(string value)
    {
        using var cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(3));
        return await _searchService.Autocomplete(value, true, cancellationTokenSource.Token).ConfigureAwait(false);
    }

    private async Task SearchIfEnterPressed(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            var request = new SearchRequest(SearchText, _selectedPage, poligonString, _selectedFacets);
            await SearchDocuments(request);
        }
    }

    private async Task UpdateSearchFacetsAndSearch(Facet facet)
    {
        SearchFacet searchFacet;

        if (!_selectedFacets.Any(f => f.Name == facet.Name))
        {
            searchFacet = new SearchFacet()
                {
                    Name = facet.Name
                };
            _selectedFacets.Add(searchFacet);
        }
        else
        {
            searchFacet = _selectedFacets.First(f => f.Name == facet.Name);
        }

        if (searchFacet.Values.Any(fv => fv == facet.Value))
        {
            searchFacet.Values.Remove(facet.Value);

            if (!searchFacet.Values.Any())
            {
                _selectedFacets.Remove(searchFacet);
            }
        }
        else
        {
            searchFacet.Values.Add(facet.Value);
        }

        var request = new SearchRequest(SearchText, _selectedPage, poligonString, _selectedFacets);

        await SearchDocuments(request);
    }

    private async Task SearchPageSelected(int page)
    {
        _selectedPage = page;
        var request = new SearchRequest(SearchText, _selectedPage, poligonString, _selectedFacets);
        await SearchDocuments(request);
    }

    private async Task SearchDocuments(SearchRequest request)
    {
        using var cancellationTokenSource = new CancellationTokenSource();

        var response = await _searchService.SearchDocuments(request, cancellationTokenSource.Token).ConfigureAwait(false);

        _searchState.Documents = response.Documents;
        _searchState.FacetableFields = response.FacetableFields;
        _searchState.Facets = response.Facets;
        _searchState.Tags = response.Tags;
        _searchState.TotalCount = response.TotalCount;
        _searchState.TotalPages = (int)response.TotalPages;
    }



    private Task UpdateEntityMapLevel(int levels)
    {
        _maxLevels = levels;
        return GenerateEntityMap();
    }

    private Task UpdateEntityMapNodes(int nodes)
    {
        _maxNodes = nodes;
        return GenerateEntityMap();
    }

    private Task UpdateEntityMapFacets(IEnumerable<string> facets)
    {
        _selectedEntityMapFacets = facets;
        return GenerateEntityMap();
    }

    private async Task GenerateEntityMap()
    {
        var entityMapData = await _searchService.GenerateEntityMap(SearchText, _selectedEntityMapFacets, _maxLevels, _maxNodes, CancellationToken.None);
        await module.InvokeVoidAsync("renderEntityGraph", _entityMapContainerId, entityMapData, _maxLevels);
    }

    private async Task GetDocumentDetails(string documentId)
    {
        _showDocumentDetails = false;

        documentDetails = await _searchService.GetDocumentDetails(documentId, CancellationToken.None);

        _showDocumentDetails = true;
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module is not null)
        {
            await module.DisposeAsync();
        }
    }
}
